#!/usr/bin/perl -w
# -*-cperl-*-

# $Id$
# $URL$

use strict;

my $ORIG_CONFIG = "aproot/conf/original/httpd.conf";
my $CONFIG = "aproot/conf/httpd.conf";
my $NEWCONFIG = "aproot/conf/httpd.conf.new";
my $LIMESTONE_CONFIG = "aproot/conf/limestone.conf";
my $LOGROTATE_CONFIG = "logrotate.conf";
my $LOGROTATE_CONFIG_NEW = "logrotate.conf.new";

my $WD = `pwd`;
chomp $WD;
my $TMPDIR = "${WD}/tmp";
my $FILEDIR = "${WD}/files";
my $LOGSDIR = "${WD}/aproot/logs";

my ($CONF_PGSQL_VHOST, $CONF_MYSQL_VHOST) = ("no", "no");

-d $TMPDIR or mkdir($TMPDIR) or die ("couldn't make $TMPDIR");
-d $FILEDIR or mkdir($FILEDIR) or die ("couldn't make $FILEDIR");
 

sub print_dav_vhost_config ($$$$$$$$$) {
  my ($config_fh, $vhost_port, $db_driver, $db_host, $db_port, $db_sock, $db_name, $db_user, $db_pass) = (shift, shift, shift, shift, shift, shift, shift, shift, shift);

  my $ROOT_PATH = "/";

  my $host_domain = $ENV{'LIMESTONE_HOST_DOMAIN'};
  my $port_part_of_host;
  if ($vhost_port) {
    $port_part_of_host = ":${vhost_port}";
  } else {
    $port_part_of_host = "";
    $vhost_port = 80;
  }


  print $config_fh qq/DBDriver $db_driver\n/;
  if ($db_driver eq "pgsql") {
    print $config_fh qq/DBDParams "host=$db_host /;
    print $config_fh qq/port=$db_port / if $db_port;
    print $config_fh qq/dbname=$db_name user=$db_user password=$db_pass"\n/;
  } elsif ($db_driver eq "mysql") {
    print $config_fh qq/  DBDParams "/;
    if ($db_sock) {
      print $config_fh "sock=$db_sock ";
    } else {
      print $config_fh "host=$db_host ";
      print $config_fh "port=$db_port " if $db_port;
    }
    print $config_fh qq/dbname=$db_name user=$db_user pass=$db_pass"\n/;
  }
  ;

  print $config_fh <<EOF

LogFormat "%h %{Host}i %u %t %D %{UNIQUE_ID}e \\"%r\\" %>s %b \\"%{Referer}i\\" \\"%{User-Agent}i\\"" limestone
CustomLog "logs/access_log" limestone

DAVLimestoneIndexCSS  http://$host_domain${port_part_of_host}/css/style.css
DAVDBMSTmpDir $TMPDIR
DAVDBMSFileDir $FILEDIR
# To allow depth: infinity PROPFINDs required by some clients.
DAVDepthInfinity on

<Location ${ROOT_PATH}>
  DAV repos
  ModMimeUsePathInfo on

  DAVUnauthenticatedAccess on
    DAVResponseRewriteCond Host                 ^(drive\\.)?[^.]+.$host_domain.*
    DAVResponseRewriteRule /home/[^/]*/?(.*)   /\$1

  AuthType Digest
  AuthName "users\@limebits.com"
  BrowserMatch ".*MSIE.*" AuthDigestEnableQueryStringHack=On

  AuthDigestProvider dbd

  Require valid-user

  #SQL query to verify a user
  #(note: DBD drivers recognise both stdio-like %s and native syntax)
  #Digest Authentication with mod_authn_dbd *requires* the query to have 2 parameters - user and realm.
  #We dont store the realm in database, hence the useless construct ' name != %s ' to dummify realm !
   AuthDBDUserRealmQuery "SELECT pwhash FROM principals INNER JOIN users ON principals.resource_id = users.principal_id WHERE name = %s and name != %s"


  # gzip content-encoding
  SetOutputFilter DEFLATE

  # Netscape 4.x has some problems...
  BrowserMatch ^Mozilla/4 gzip-only-text/html

  # Netscape 4.06-4.08 have some more problems
  BrowserMatch ^Mozilla/4\.0[678] no-gzip

  # MSIE masquerades as Netscape, but it is fine
  BrowserMatch \bMSIE !no-gzip !gzip-only-text/html
  # Don't compress images
  SetEnvIfNoCase Request_URI \.(?:gif|jpe?g|png)\$ no-gzip dont-vary

  # Make sure proxies don't deliver the wrong content
  Header append Vary User-Agent env=!dont-vary

</Location>

DeflateCompressionLevel 3

DeflateFilterNote Input instream
DeflateFilterNote Output outstream
DeflateFilterNote Ratio ratio

LogFormat '"\%r" \%{outstream}n/\%{instream}n (\%{ratio}n\%\%)' deflate
CustomLog logs/deflate_log deflate


NameVirtualHost *:${vhost_port}
Listen $vhost_port

<VirtualHost *:${vhost_port}>
  ServerName ${host_domain}:${vhost_port}

</VirtualHost>
EOF
;
}

sub print_logrotate_config($) {
  my ($config_fh) = @_;

  print $config_fh <<EOF
${LOGSDIR}/*log {
    weekly
    missingok
    compress
    delaycompress
    notifempty
    sharedscripts
    postrotate
        ./aproot/bin/apachectl graceful
    endscript
}
EOF
;
}

sub rename_or_die($$) {
  my ($src, $dest) = @_;
  rename($src, $dest) or
    die("couldn't rename $src to $dest");
}

my ($sql1, $sql2) = (shift, shift);
$CONF_PGSQL_VHOST="yes" if ($sql1 && ($sql1 eq "pgsql") || $sql2 && ($sql2 eq "pgsql"));
$CONF_MYSQL_VHOST="yes" if ($sql1 && ($sql1 eq "mysql") || $sql2 && ($sql2 eq "mysql"));

open(LIMESTONE_CONFIG, '>', $LIMESTONE_CONFIG) or die("couldn't open $LIMESTONE_CONFIG");

if ($CONF_PGSQL_VHOST eq "yes") {
  my $LSPORT = $ENV{'LIMESTONE_PGSQL_VHOST_PORT'};
  my $DBHOST = $ENV{'LIMESTONE_PGSQL_DB_HOST'};
  my $DBPORT = $ENV{'LIMESTONE_PGSQL_DB_PORT'};
  my $DBNAME = $ENV{'LIMESTONE_PGSQL_DB_NAME'};
  my $DBUSER = $ENV{'LIMESTONE_PGSQL_DB_USER'};
  my $DBPASS = $ENV{'LIMESTONE_PGSQL_DB_PASS'};
  print_dav_vhost_config
    (*LIMESTONE_CONFIG, $LSPORT, "pgsql", $DBHOST, $DBPORT, 0, $DBNAME, $DBUSER, $DBPASS)
}

if ($CONF_MYSQL_VHOST eq "yes") {
  my $LSPORT = $ENV{'LIMESTONE_MYSQL_VHOST_PORT'};
  my $DBHOST = $ENV{'LIMESTONE_MYSQL_DB_HOST'};
  my $DBPORT = $ENV{'LIMESTONE_MYSQL_DB_PORT'};
  my $DBSOCK = $ENV{'LIMESTONE_MYSQL_DB_SOCK'};
  my $DBNAME = $ENV{'LIMESTONE_MYSQL_DB_NAME'};
  my $DBUSER = $ENV{'LIMESTONE_MYSQL_DB_USER'};
  my $DBPASS = $ENV{'LIMESTONE_MYSQL_DB_PASS'};
  print_dav_vhost_config
    (*LIMESTONE_CONFIG, $LSPORT, "mysql", $DBHOST, $DBPORT, $DBSOCK, $DBNAME, $DBUSER, $DBPASS)
}

close(LIMESTONE_CONFIG) or die("couldn't close $LIMESTONE_CONFIG");

open(ORIG_CONFIG, $ORIG_CONFIG) or die("couldn't open $ORIG_CONFIG");
open(NEWCONFIG, '>', $NEWCONFIG) or die("couldn't open $NEWCONFIG");
  

while (<ORIG_CONFIG>) {
  s/^Listen 80$/#Listen 80/;
  s|(CustomLog "logs/access_log" common$)|#$1|;
  print NEWCONFIG;
}
print NEWCONFIG "\nInclude conf/limestone.conf\n";


close(ORIG_CONFIG) or die("couldn't close $ORIG_CONFIG");
close(NEWCONFIG) or die("couldn't close $NEWCONFIG");

open(LOGROTATE_CONFIG_NEW, '>', $LOGROTATE_CONFIG_NEW) or
  die("couldn't open $LOGROTATE_CONFIG_NEW");
print_logrotate_config(*LOGROTATE_CONFIG_NEW);
close(LOGROTATE_CONFIG_NEW);

rename_or_die($NEWCONFIG, $CONFIG);
rename_or_die($LOGROTATE_CONFIG_NEW, $LOGROTATE_CONFIG);

exit 0;
    
